{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///Users/viniciusbaldochi/despasys/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client'\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined\n}\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient({\n  log: process.env.NODE_ENV === 'development' ? ['warn', 'error'] : ['error'],\n  datasources: {\n    db: {\n      url: process.env.DATABASE_URL\n    }\n  },\n  // Configurações de conexão otimizadas\n  transactionOptions: {\n    timeout: 10000, // 10 segundos\n    maxWait: 5000,  // 5 segundos max wait\n  }\n})\n\n// Função para executar queries com retry automático\nexport async function executeWithRetry<T>(\n  operation: () => Promise<T>,\n  maxRetries = 3,\n  delay = 1000\n): Promise<T> {\n  let lastError: Error\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation()\n    } catch (error: any) {\n      lastError = error\n      \n      // Se for erro de conexão, tentar reconectar\n      if (error.code === 'P1017' || error.message?.includes('closed')) {\n        console.warn(`Database connection closed (attempt ${attempt}/${maxRetries}), reconnecting...`)\n        try {\n          await prisma.$disconnect()\n          await new Promise(resolve => setTimeout(resolve, delay))\n          await prisma.$connect()\n        } catch (reconnectError) {\n          console.warn('Reconnection failed:', reconnectError)\n        }\n      } else {\n        console.warn(`Database operation failed (attempt ${attempt}/${maxRetries}):`, error.message)\n      }\n      \n      if (attempt === maxRetries) {\n        throw lastError\n      }\n      \n      // Exponential backoff\n      await new Promise(resolve => setTimeout(resolve, delay * attempt))\n    }\n  }\n  \n  throw lastError!\n}\n\n// Configurar graceful shutdown apenas uma vez\nif (typeof window === 'undefined') {\n  let shutdownHandlersAdded = false\n  \n  if (!shutdownHandlersAdded) {\n    shutdownHandlersAdded = true\n    \n    process.on('SIGINT', async () => {\n      console.log('Received SIGINT, disconnecting from database...')\n      await prisma.$disconnect()\n      process.exit(0)\n    })\n    \n    process.on('SIGTERM', async () => {\n      console.log('Received SIGTERM, disconnecting from database...')\n      await prisma.$disconnect()\n      process.exit(0)\n    })\n  }\n}\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6HAAA,CAAA,eAAY,CAAC;IAC/D,KAAK,uCAAyC;QAAC;QAAQ;KAAQ,GAAG;IAClE,aAAa;QACX,IAAI;YACF,KAAK,QAAQ,GAAG,CAAC,YAAY;QAC/B;IACF;IACA,sCAAsC;IACtC,oBAAoB;QAClB,SAAS;QACT,SAAS;IACX;AACF;AAGO,eAAe,iBACpB,SAA2B,EAC3B,aAAa,CAAC,EACd,QAAQ,IAAI;IAEZ,IAAI;IAEJ,IAAK,IAAI,UAAU,GAAG,WAAW,YAAY,UAAW;QACtD,IAAI;YACF,OAAO,MAAM;QACf,EAAE,OAAO,OAAY;YACnB,YAAY;YAEZ,4CAA4C;YAC5C,IAAI,MAAM,IAAI,KAAK,WAAW,MAAM,OAAO,EAAE,SAAS,WAAW;gBAC/D,QAAQ,IAAI,CAAC,CAAC,oCAAoC,EAAE,QAAQ,CAAC,EAAE,WAAW,kBAAkB,CAAC;gBAC7F,IAAI;oBACF,MAAM,OAAO,WAAW;oBACxB,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS;oBACjD,MAAM,OAAO,QAAQ;gBACvB,EAAE,OAAO,gBAAgB;oBACvB,QAAQ,IAAI,CAAC,wBAAwB;gBACvC;YACF,OAAO;gBACL,QAAQ,IAAI,CAAC,CAAC,mCAAmC,EAAE,QAAQ,CAAC,EAAE,WAAW,EAAE,CAAC,EAAE,MAAM,OAAO;YAC7F;YAEA,IAAI,YAAY,YAAY;gBAC1B,MAAM;YACR;YAEA,sBAAsB;YACtB,MAAM,IAAI,QAAQ,CAAA,UAAW,WAAW,SAAS,QAAQ;QAC3D;IACF;IAEA,MAAM;AACR;AAEA,8CAA8C;AAC9C,wCAAmC;IACjC,IAAI,wBAAwB;IAE5B,IAAI,CAAC,uBAAuB;QAC1B,wBAAwB;QAExB,QAAQ,EAAE,CAAC,UAAU;YACnB,QAAQ,GAAG,CAAC;YACZ,MAAM,OAAO,WAAW;YACxB,QAAQ,IAAI,CAAC;QACf;QAEA,QAAQ,EAAE,CAAC,WAAW;YACpB,QAAQ,GAAG,CAAC;YACZ,MAAM,OAAO,WAAW;YACxB,QAAQ,IAAI,CAAC;QACf;IACF;AACF;AAEA,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 148, "column": 0}, "map": {"version":3,"sources":["file:///Users/viniciusbaldochi/despasys/src/app/api/tenant/%5Bdomain%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { prisma } from '@/lib/prisma'\n\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ domain: string }> }\n) {\n  try {\n    const { domain } = await params\n\n    if (!domain) {\n      return NextResponse.json(\n        { error: 'Domain é obrigatório' },\n        { status: 400 }\n      )\n    }\n\n    const tenant = await prisma.tenant.findUnique({\n      where: { domain },\n      select: {\n        id: true,\n        name: true,\n        domain: true,\n        status: true,\n        plan: true,\n        trialEndsAt: true,\n        createdAt: true\n      }\n    })\n\n    if (!tenant) {\n      return NextResponse.json(\n        { error: 'Tenant não encontrado' },\n        { status: 404 }\n      )\n    }\n\n    return NextResponse.json(tenant)\n  } catch (error) {\n    console.error('Erro ao buscar tenant:', error)\n    return NextResponse.json(\n      { error: 'Erro interno do servidor' },\n      { status: 500 }\n    )\n  }\n}\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,eAAe,IACpB,OAAoB,EACpB,EAAE,MAAM,EAA2C;IAEnD,IAAI;QACF,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM;QAEzB,IAAI,CAAC,QAAQ;YACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAuB,GAChC;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,SAAS,MAAM,sHAAA,CAAA,SAAM,CAAC,MAAM,CAAC,UAAU,CAAC;YAC5C,OAAO;gBAAE;YAAO;YAChB,QAAQ;gBACN,IAAI;gBACJ,MAAM;gBACN,QAAQ;gBACR,QAAQ;gBACR,MAAM;gBACN,aAAa;gBACb,WAAW;YACb;QACF;QAEA,IAAI,CAAC,QAAQ;YACX,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAwB,GACjC;gBAAE,QAAQ;YAAI;QAElB;QAEA,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CAAC;IAC3B,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QACxC,OAAO,gIAAA,CAAA,eAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA2B,GACpC;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}